diff --git a/Cargo.lock b/Cargo.lock
index a4a8ca9..1421e40 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -1,5 +1,7 @@
 # This file is automatically @generated by Cargo.
 # It is not intended for manual editing.
+version = 3
+
 [[package]]
 name = "Inflector"
 version = "0.11.4"
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..544011b
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,63 @@
+
+
+# Porcelain
+# ###############
+.PHONY: env-up env-down env-recreate container run build lint test
+
+run: setup ## run the app
+	cargo run  -- --dev --tmp
+
+env-up: ## set up dev environment
+	@echo "Not implemented"; false
+
+env-down: ## tear down dev environment
+	@echo "Not implemented"; false
+
+env-recreate: env-down env-up ## deconstruct current env and create another one
+
+build: setup ## create artifact
+	cargo build
+
+lint: setup ## run static analysis
+	@echo "Not implemented"; false
+
+test: setup ## run all tests
+	@echo "Not implemented"; false
+
+container: build ## create container
+	#docker build -t lmap .
+	@echo "Not implemented"; false
+
+# Plumbing
+# ###############
+.PHONY: setup gitclean gitclean-with-libs
+
+setup:
+
+gitclean:
+	@# will remove everything in .gitignore expect for blocks starting with dep* or lib* comment
+	diff --new-line-format="" --unchanged-line-format="" <(grep -v '^#' .gitignore | grep '\S' | sort) <(awk '/^# *(dep|lib)/,/^$/' testowy | head -n -1 | tail -n +2 | sort) | xargs rm -rf
+
+gitclean-with-libs:
+	diff --new-line-format="" --unchanged-line-format="" <(grep -v '^#' .gitignore | grep '\S' | sort) | xargs rm -rf
+
+# Helpers
+# ###############
+.PHONY:
+
+# Utilities
+# ###############
+.PHONY: help todo clean really_clean init
+init: ## one time setup
+	direnv allow .
+
+todo: ## list all TODOs in the project
+	git grep -I --line-number TODO | grep -v 'list all TODOs in the project' | grep TODO
+
+clean: gitclean ## remove artifacts
+
+really_clean: gitclean-with-libs ## remove EVERYTHING
+
+help: ## print this message
+	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
+.DEFAULT_GOAL := help
diff --git a/pallets/template/src/benchmarking.rs b/pallets/template/src/benchmarking.rs
deleted file mode 100644
index 93d7fa3..0000000
--- a/pallets/template/src/benchmarking.rs
+++ /dev/null
@@ -1,24 +0,0 @@
-//! Benchmarking setup for pallet-template
-
-use super::*;
-
-use frame_system::RawOrigin;
-use frame_benchmarking::{benchmarks, whitelisted_caller, impl_benchmark_test_suite};
-#[allow(unused)]
-use crate::Pallet as Template;
-
-benchmarks! {
-	do_something {
-		let s in 0 .. 100;
-		let caller: T::AccountId = whitelisted_caller();
-	}: _(RawOrigin::Signed(caller), s)
-	verify {
-		assert_eq!(Something::<T>::get(), Some(s));
-	}
-}
-
-impl_benchmark_test_suite!(
-	Template,
-	crate::mock::new_test_ext(),
-	crate::mock::Test,
-);
diff --git a/pallets/template/src/lib.rs b/pallets/template/src/lib.rs
index 373a56f..530a683 100644
--- a/pallets/template/src/lib.rs
+++ b/pallets/template/src/lib.rs
@@ -1,24 +1,20 @@
 #![cfg_attr(not(feature = "std"), no_std)]
 
-/// Edit this file to define custom logic or remove it if it is not needed.
-/// Learn more about FRAME and the core library of Substrate FRAME pallets:
-/// <https://substrate.dev/docs/en/knowledgebase/runtime/frame>
-
 pub use pallet::*;
-
-#[cfg(test)]
-mod mock;
-
+use frame_support::inherent::Vec;
 #[cfg(test)]
 mod tests;
 
-#[cfg(feature = "runtime-benchmarks")]
-mod benchmarking;
+type String = Vec<u8>;
 
 #[frame_support::pallet]
 pub mod pallet {
 	use frame_support::{dispatch::DispatchResult, pallet_prelude::*};
 	use frame_system::pallet_prelude::*;
+	use frame_support::sp_runtime::traits::Hash;
+	use core::convert::TryInto;
+	use crate::*;
+
 
 	/// Configure the pallet by specifying the parameters and types on which it depends.
 	#[pallet::config]
@@ -31,74 +27,257 @@ pub mod pallet {
 	#[pallet::generate_store(pub(super) trait Store)]
 	pub struct Pallet<T>(_);
 
-	// The pallet's runtime storage items.
-	// https://substrate.dev/docs/en/knowledgebase/runtime/storage
-	#[pallet::storage]
-	#[pallet::getter(fn something)]
-	// Learn more about declaring storage items:
-	// https://substrate.dev/docs/en/knowledgebase/runtime/storage#declaring-storage-items
-	pub type Something<T> = StorageValue<_, u32>;
-
-	// Pallets use events to inform users when important changes are made.
-	// https://substrate.dev/docs/en/knowledgebase/runtime/events
 	#[pallet::event]
 	#[pallet::metadata(T::AccountId = "AccountId")]
 	#[pallet::generate_deposit(pub(super) fn deposit_event)]
 	pub enum Event<T: Config> {
-		/// Event documentation should end with an array that provides descriptive names for event
-		/// parameters. [something, who]
-		SomethingStored(u32, T::AccountId),
+		SmartContractCreated(u32),
+		SmartContractEmission(String),
 	}
 
-	// Errors inform users that something went wrong.
-	#[pallet::error]
-	pub enum Error<T> {
-		/// Error names should be descriptive.
-		NoneValue,
-		/// Errors should have helpful documentation associated with them.
-		StorageOverflow,
+	#[pallet::storage]
+	#[pallet::getter(fn retreive_contract)]
+	pub type Contracts<T> = StorageMap<_, Identity, u32, Vec<u8>, ValueQuery>;
+
+	// inspired by hex crate implmementation
+	fn val(c: u8) -> u8 {
+		match c {
+			b'A'..=b'F' => (c - b'A' + 10),
+			b'a'..=b'f' => (c - b'a' + 10),
+			b'0'..=b'9' => (c - b'0'),
+			_ => 123, // error, but no need for handling
+		}
+	}
+
+	// https://stackoverflow.com/a/36676814
+	fn as_u32_le(array: &[u8]) -> u32 {
+		((array[0] as u32) <<  0) +
+		((array[1] as u32) <<  8) +
+		((array[2] as u32) << 16) +
+		((array[3] as u32) << 24)
 	}
 
-	// Dispatchable functions allows users to interact with the pallet and invoke state changes.
-	// These functions materialize as "extrinsics", which are often compared to transactions.
-	// Dispatchable functions must be annotated with a weight and must return a DispatchResult.
 	#[pallet::call]
 	impl<T:Config> Pallet<T> {
-		/// An example dispatchable that takes a singles value as a parameter, writes the value to
-		/// storage and emits an event. This function must be dispatched by a signed extrinsic.
 		#[pallet::weight(10_000 + T::DbWeight::get().writes(1))]
-		pub fn do_something(origin: OriginFor<T>, something: u32) -> DispatchResult {
-			// Check that the extrinsic was signed and get the signer.
-			// This function will return an error if the extrinsic is not signed.
-			// https://substrate.dev/docs/en/knowledgebase/runtime/origin
-			let who = ensure_signed(origin)?;
-
-			// Update storage.
-			<Something<T>>::put(something);
-
-			// Emit an event.
-			Self::deposit_event(Event::SomethingStored(something, who));
-			// Return a successful DispatchResultWithPostInfo
+		pub fn upload_contract(origin: OriginFor<T>, sc_encoded: Vec<u8>) -> DispatchResult {
+			let _ = ensure_signed(origin)?;
+
+			let sc: Vec<u8> = sc_encoded.chunks(2)
+				.map(|pair| val(pair[0]) << 4 | val(pair[1]))
+				.collect();
+
+			let contract_blake2_hash = T::Hashing::hash(&sc);
+			let contract_address: u32 = as_u32_le(contract_blake2_hash.as_ref());
+
+			<Contracts<T>>::insert(contract_address, sc);
+
+			Self::deposit_event(Event::SmartContractCreated(contract_address));
+
+			Ok(())
+		}
+
+		#[pallet::weight(10_000 + T::DbWeight::get().writes(1))]
+		pub fn execute_contract(origin: OriginFor<T>, sc_address: u32) -> DispatchResult {
+			let _ = ensure_signed(origin)?;
+			let mut jvm = JorgeVM::new();
+			let current_block: u32 =
+			<frame_system::Pallet<T>>::block_number().try_into().unwrap_or(0);
+
+			let sc = Contracts::<T>::get(sc_address);
+			let (code, constants) = JorgeVM::parse(sc);
+			jvm.supply_blocknumber(current_block);
+
+			jvm.run_until_complete(&code);
+
+			for r_idx in jvm.results.iter() {
+				let r = &constants[*r_idx];
+				Self::deposit_event(Event::SmartContractEmission(r.to_vec()));
+			}
+
 			Ok(())
 		}
+	}
+}
+
+#[derive(Eq, PartialEq, Debug)]
+enum Op {
+	Iconst2,
+	Irem,
+	Blocknumber,
+	Emit(usize),
+	Ifeq(usize),
+	Goto(usize),
+	Nop,
+	Invalid,
+}
+
+struct JorgeVM {
+	stack: Vec<u32>,
+	results: Vec<usize>,
+	blocknumber: u32,
+}
+
+impl JorgeVM {
+	pub fn new() -> JorgeVM {
+		JorgeVM{stack: Vec::new(), results: Vec::new(), blocknumber: 123}
+	}
+
+	fn _push(self: &mut Self, v: u32) {
+		self.stack.push(v);
+	}
+
+	fn _execute(self: &mut Self, op: &Op, ip: &usize) -> usize {
+		use Op::*;
+		match op {
+			Iconst2 => {
+				self.stack.push(2);
+			}
+			Irem => {
+				let a = self.stack.pop().expect("yolo");
+				let b = self.stack.pop().expect("yolo");
+				self.stack.push(b % a);
+			}
+			Blocknumber => {
+				self.stack.push(self.blocknumber);
+			}
+			Emit(c_idx) => {
+				self.results.push(*c_idx);
+			}
+			Ifeq(jmp_target) => {
+				let val = self.stack.pop().expect("yolo");
+				if val == 0 {
+					return *jmp_target;
+				}
+			}
+			Goto(jmp_target) => {
+				return *jmp_target;
+			}
+			Nop => {},
+			Invalid => { panic!("Invalid opcode, aaaaaa!") },
+		}
+
+		*ip + 1
+	}
+
+	fn supply_blocknumber(self: &mut Self, n: u32) {
+		self.blocknumber = n;
+	}
+
+	fn run_until_complete(self: &mut Self, code: &Vec<Op>) {
+		let mut ip: usize = 0;
+		while ip < code.len() {
+			let op = &code[ip];
+
+			ip = self._execute(&op, &ip);
+		}
+	}
+
+	pub fn parse(bytecode: Vec<u8>) -> (Vec<Op>, Vec<String>) {
+		let mut p = 1;
+		let mut instruction_count = 0;
+		let mut result = Vec::new();
+		let mut constants = Vec::new();
+		let mut offsets_to_recompute = Vec::new();
+		let mut wideops = Vec::new();
+		wideops.push((0, 1));
+
+		let operations_length = bytecode[0] as usize;
+
+		// bytecode parsing
+		while p < (operations_length + 1) {
+			use Op::*;
+			let op_codepoint = bytecode[p];
+
+			let op = match op_codepoint {
+				0xcb => Blocknumber,
+				0x70 => Irem,
+				0x05 => Iconst2,
+				0x00 => Nop,
+				0xa7 => {
+					p += 1;
+					let hibranchbyte = bytecode[p];
+					p += 1;
+					let lobranchbyte = bytecode[p];
+
+					offsets_to_recompute.push(instruction_count);
+					wideops.push((p - 2, 2));
+
+					Goto((hibranchbyte as usize) << 8 | lobranchbyte as usize + p - 2)
+				}
+				0xcc => {
+					p += 1;
+					let c_idx = bytecode[p];
+					wideops.push((p - 1, 1));
+
+					Emit(c_idx as usize)
+				}
+				0x99 => {
+					p += 1;
+					let hibranchbyte = bytecode[p];
+					p += 1;
+					let lobranchbyte = bytecode[p];
+
+					offsets_to_recompute.push(instruction_count);
+					wideops.push((p - 2, 2));
+
+					Ifeq((hibranchbyte as usize) << 8 | lobranchbyte as usize + p - 2)
+				}
+				_ => Invalid,
+			};
+
+			result.push(op);
+
+			p += 1;
+			instruction_count += 1;
+		}
 
-		/// An example dispatchable that may throw a custom error.
-		#[pallet::weight(10_000 + T::DbWeight::get().reads_writes(1,1))]
-		pub fn cause_error(origin: OriginFor<T>) -> DispatchResult {
-			let _who = ensure_signed(origin)?;
-
-			// Read a value from storage.
-			match <Something<T>>::get() {
-				// Return an error if the value has not been set.
-				None => Err(Error::<T>::NoneValue)?,
-				Some(old) => {
-					// Increment the value read from storage; will error in the event of overflow.
-					let new = old.checked_add(1).ok_or(Error::<T>::StorageOverflow)?;
-					// Update the value in storage with the incremented result.
-					<Something<T>>::put(new);
-					Ok(())
-				},
+		// constant extraction
+		let mut c = String::new();
+		while p < bytecode.len() {
+			let constant_codepoint = bytecode[p];
+			match constant_codepoint {
+				0 => {
+					constants.push(c);
+					c = String::new();
+				}
+				c_ => {
+					c.push(c_);
+				}
 			}
+
+			p += 1;
 		}
+
+		// jumping offset recalculation
+		for i in offsets_to_recompute.iter() {
+			use Op::*;
+			let op = &result[*i];
+			let replacement_op = match op {
+				Goto(offset) => {
+					let mut new_offset = *offset;
+					for (pos, count) in wideops.iter() {
+						if pos < offset {
+							new_offset -= count;
+						}
+					}
+					Goto(new_offset)
+				}
+				Ifeq(offset) => {
+					// TODO: this is duplicated, extract to function
+					let mut new_offset = *offset;
+					for (pos, count) in wideops.iter() {
+						if pos < offset {
+							new_offset -= count;
+						}
+					}
+					Ifeq(new_offset)
+				}
+				_ => Invalid,
+			};
+			result[*i] = replacement_op;
+		}
+
+		(result, constants)
 	}
 }
diff --git a/pallets/template/src/mock.rs b/pallets/template/src/mock.rs
deleted file mode 100644
index 8719bcb..0000000
--- a/pallets/template/src/mock.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use crate as pallet_template;
-use sp_core::H256;
-use frame_support::parameter_types;
-use sp_runtime::{
-	traits::{BlakeTwo256, IdentityLookup}, testing::Header,
-};
-use frame_system as system;
-
-type UncheckedExtrinsic = frame_system::mocking::MockUncheckedExtrinsic<Test>;
-type Block = frame_system::mocking::MockBlock<Test>;
-
-// Configure a mock runtime to test the pallet.
-frame_support::construct_runtime!(
-	pub enum Test where
-		Block = Block,
-		NodeBlock = Block,
-		UncheckedExtrinsic = UncheckedExtrinsic,
-	{
-		System: frame_system::{Pallet, Call, Config, Storage, Event<T>},
-		TemplateModule: pallet_template::{Pallet, Call, Storage, Event<T>},
-	}
-);
-
-parameter_types! {
-	pub const BlockHashCount: u64 = 250;
-	pub const SS58Prefix: u8 = 42;
-}
-
-impl system::Config for Test {
-	type BaseCallFilter = ();
-	type BlockWeights = ();
-	type BlockLength = ();
-	type DbWeight = ();
-	type Origin = Origin;
-	type Call = Call;
-	type Index = u64;
-	type BlockNumber = u64;
-	type Hash = H256;
-	type Hashing = BlakeTwo256;
-	type AccountId = u64;
-	type Lookup = IdentityLookup<Self::AccountId>;
-	type Header = Header;
-	type Event = Event;
-	type BlockHashCount = BlockHashCount;
-	type Version = ();
-	type PalletInfo = PalletInfo;
-	type AccountData = ();
-	type OnNewAccount = ();
-	type OnKilledAccount = ();
-	type SystemWeightInfo = ();
-	type SS58Prefix = SS58Prefix;
-	type OnSetCode = ();
-}
-
-impl pallet_template::Config for Test {
-	type Event = Event;
-}
-
-// Build genesis storage according to the mock runtime.
-pub fn new_test_ext() -> sp_io::TestExternalities {
-	system::GenesisConfig::default().build_storage::<Test>().unwrap().into()
-}
diff --git a/pallets/template/src/tests.rs b/pallets/template/src/tests.rs
index 3356b29..9394926 100644
--- a/pallets/template/src/tests.rs
+++ b/pallets/template/src/tests.rs
@@ -1,23 +1,172 @@
-use crate::{Error, mock::*};
-use frame_support::{assert_ok, assert_noop};
+use super::*;
 
 #[test]
-fn it_works_for_default_value() {
-	new_test_ext().execute_with(|| {
-		// Dispatch a signed extrinsic.
-		assert_ok!(TemplateModule::do_something(Origin::signed(1), 42));
-		// Read pallet storage and assert an expected result.
-		assert_eq!(TemplateModule::something(), Some(42));
-	});
+fn vm_execute_iconst() {
+	let mut jvm = JorgeVM::new();
+
+	jvm._execute(&Op::Iconst2, &0);
+
+	assert!(jvm.stack == vec![2]);
 }
 
 #[test]
-fn correct_error_for_none_value() {
-	new_test_ext().execute_with(|| {
-		// Ensure the expected error is thrown when no value is present.
-		assert_noop!(
-			TemplateModule::cause_error(Origin::signed(1)),
-			Error::<Test>::NoneValue
-		);
-	});
+fn vm_execute_irem() {
+	let mut jvm = JorgeVM::new();
+	jvm._push(5);
+	jvm._push(2);
+
+	jvm._execute(&Op::Irem, &0);
+
+	assert!(jvm.stack == vec![1]);
+}
+
+#[test]
+fn vm_execute_blocknumber() {
+	let mut jvm = JorgeVM::new();
+
+	jvm._execute(&Op::Blocknumber, &0);
+
+	assert!(jvm.stack == vec![123]);
+}
+
+#[test]
+fn vm_execute_emit() {
+	let mut jvm = JorgeVM::new();
+
+	jvm._execute(&Op::Emit(0), &0);
+	jvm._execute(&Op::Emit(1), &1);
+
+	assert!(jvm.stack.is_empty());
+	assert!(jvm.results == vec![0, 1]);
+}
+
+#[test]
+fn vm_can_run() {
+	let mut jvm = JorgeVM::new();
+	let code = vec![Op::Iconst2, Op::Iconst2];
+
+	jvm.run_until_complete(&code);
+
+	assert!(jvm.stack == vec![2, 2]);
+}
+
+
+
+#[test]
+fn run_programme_mod_0() {
+	use Op::*;
+	let mut jvm = JorgeVM::new();
+	let code = vec![
+		Blocknumber,
+		Iconst2,
+		Irem,
+		Ifeq(6),
+		Emit(0),
+		Goto(7),
+		Emit(1),
+		Nop,
+	];
+	jvm.supply_blocknumber(124);
+
+	jvm.run_until_complete(&code);
+
+	assert!(jvm.stack.is_empty());
+	assert!(jvm.results == vec![1]);
+}
+
+#[test]
+fn run_programme_mod_1() {
+	use Op::*;
+	let mut jvm = JorgeVM::new();
+	let code = vec![
+		Blocknumber,
+		Iconst2,
+		Irem,
+		Ifeq(6),
+		Emit(0),
+		Goto(7),
+		Emit(1),
+		Nop,
+	];
+
+	jvm.run_until_complete(&code);
+
+	assert!(jvm.stack.is_empty());
+	assert!(jvm.results == vec![0]);
+}
+
+
+#[test]
+fn parse_ifeq() {
+	use Op::*;
+	let bytecode = vec![
+		0x03,
+		0x99,
+		0x01,
+		0x02,
+	];
+	let refference = vec![
+		Ifeq(256),
+	];
+
+	assert_eq!(JorgeVM::parse(bytecode).0, refference);
+}
+
+#[test]
+fn parse_programme() {
+	use Op::*;
+	let bytecode = vec![
+		0x0e,
+		0xcb,
+		0x05,
+		0x70,
+		0x99,
+		0x00,
+		0x08,
+		0xcc,
+		0x00,
+		0xa7,
+		0x00,
+		0x05,
+		0xcc,
+		0x01,
+		0x00,
+			// constants
+		0x59,
+		0x6f,
+		0x75,
+		0x20,
+		0x6c,
+		0x6f,
+		0x73,
+		0x65,
+		0x00,
+		0x59,
+		0x6f,
+		0x75,
+		0x20,
+		0x77,
+		0x69,
+		0x6e,
+		0x00,
+	];
+	let refference = vec![
+		Blocknumber,
+		Iconst2,
+		Irem,
+		Ifeq(6),
+		Emit(0),
+		Goto(7),
+		Emit(1),
+		Nop,
+	];
+	let constant_refference = vec![
+		"You lose".as_bytes(),
+		"You win".as_bytes(),
+	];
+
+	let parsed = JorgeVM::parse(bytecode);
+
+	assert_eq!(parsed.0, refference);
+	assert_eq!(parsed.1, constant_refference);
 }
